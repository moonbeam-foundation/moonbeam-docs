name: Rose

on:
  workflow_dispatch:
    inputs:
      base_ref:
        description: 'Baseref (default branch)'
        required: true
        default: 'main'
      head_ref:
        description: 'Headref (feature branch)'
        required: true
        default: ''
      languages:
        description: 'ISO Codes of target languages (space-separated)'
        required: true
        default: ''
      include_full:
        description: 'Set to true to send full files (even if only a line changed)'
        required: false
        default: 'false'
      file_filter:
        description: 'Separated list of files to translate (repo-relative paths). Special values: run_queue, first_run'
        required: false
        default: ''
  pull_request:
    types:
      - opened
      - reopened
      - synchronize
      - edited
  push:
    branches:
      - '**'
  schedule:
    # Adjust time as needed (UTC).
    - cron: '0 20 * * 0'

permissions:
  contents: read

env:
  # Repo variable that stores translation languages.
  ROSE_LANGS_RAW: ${{ vars.ROSE_LANGUAGES }}

jobs:
  label-sync:
    name: Sync Rose Labels
    if: ${{ github.event_name == 'pull_request' && github.event.action != 'closed' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: read
      pull-requests: write
    steps:
      # Commit message commands: +rose / -rose and +rose:pt / -rose:pt anywhere in the message.
      # Latest commit = last commit in the PR list that contains a command (API list order).
      # UI label changes override older commit commands until a newer commit command is added.
      - name: Sync labels from commit commands
        uses: actions/github-script@v7
        env:
          ROSE_LANGS_RAW: ${{ vars.ROSE_LANGUAGES }}
        with:
          script: |
            const varName = 'ROSE_LANGUAGES';
            const rawLangs = process.env.ROSE_LANGS_RAW || '';

            const parseLanguages = (value) => {
              const trimmed = String(value || '').trim();
              if (!trimmed) {
                throw new Error(
                  `Repository variable "${varName}" is required but not set (e.g., "pt es fr" or ["pt","es","fr"]).`
                );
              }
              if (trimmed.startsWith('[')) {
                const parsed = JSON.parse(trimmed);
                if (!Array.isArray(parsed)) {
                  throw new Error(`Repository variable "${varName}" must be a JSON array string.`);
                }
                return parsed.map((item) => String(item).trim()).filter(Boolean);
              }
              return trimmed.split(/[,\s]+/).map((item) => item.trim()).filter(Boolean);
            };

            const languages = parseLanguages(rawLangs);
            const langSet = new Set(languages.map((lang) => lang.toLowerCase()));
            const pr = context.payload.pull_request;
            if (!pr) {
              throw new Error('No pull request context available for label sync.');
            }

            const allowedLabel = (label) => {
              if (label === 'rose') {
                return true;
              }
              if (label.startsWith('rose:')) {
                return langSet.has(label.split(':')[1]);
              }
              return false;
            };

            const commits = await github.paginate(github.rest.pulls.listCommits, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              per_page: 100,
            });

            const commandRegex = /[+-]rose(?!-skip)(?::[a-zA-Z0-9._-]+)?/g;
            const labelActions = new Map();

            for (const commit of commits) {
              const message = commit.commit?.message || '';
              const commitDate = new Date(
                commit.commit?.committer?.date || commit.commit?.author?.date || 0
              ).getTime();
              const matches = message.match(commandRegex);
              if (!matches) {
                continue;
              }
              for (const token of matches) {
                const action = token.startsWith('+') ? 'add' : 'remove';
                const label = token.slice(1).toLowerCase();
                if (!allowedLabel(label)) {
                  continue;
                }
                labelActions.set(label, { action, timestamp: commitDate });
              }
            }

            if (labelActions.size === 0) {
              core.info('No rose label commands found in commit messages.');
              return;
            }

            const events = await github.paginate(github.rest.issues.listEvents, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              per_page: 100,
            });

            const labelEventTimes = new Map();
            for (const event of events) {
              if (event.event !== 'labeled' && event.event !== 'unlabeled') {
                continue;
              }
              const labelName = event.label?.name?.toLowerCase();
              if (!labelName || !allowedLabel(labelName)) {
                continue;
              }
              const eventTime = new Date(event.created_at || 0).getTime();
              const prevTime = labelEventTimes.get(labelName) || 0;
              if (eventTime > prevTime) {
                labelEventTimes.set(labelName, eventTime);
              }
            }

            const currentLabels = (pr.labels || []).map((label) => label.name.toLowerCase());
            const toAdd = [];
            const toRemove = [];

            for (const [label, data] of labelActions.entries()) {
              const action = data.action;
              const commandTime = data.timestamp || 0;
              const labelEventTime = labelEventTimes.get(label) || 0;
              if (labelEventTime > commandTime) {
                core.info(
                  `Skipping ${label} from commit commands; UI label change is newer.`
                );
                continue;
              }
              if (action === 'add' && !currentLabels.includes(label)) {
                toAdd.push(label);
              }
              if (action === 'remove' && currentLabels.includes(label)) {
                toRemove.push(label);
              }
            }

            if (toAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: toAdd,
              });
            }

            for (const label of toRemove) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                name: label,
              });
            }

  process-queue:
    name: Process Rose PRs
    needs: guard
    if: ${{ github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && inputs.file_filter == 'run_queue' && needs.guard.outputs.allowed == 'true') }}
    runs-on: ubuntu-latest
    outputs:
      success_payload: ${{ steps.success_payload.outputs.payload }}
      success_count: ${{ steps.process_queue.outputs.success_count }}
    permissions:
      actions: read
      contents: write
      issues: read
      pull-requests: read
    env:
      N8N_WEBHOOK_URL: ${{ secrets.N8N_WEBHOOK_URL_TR }}
      ROSE_N8N_SENDING_TOKEN: ${{ secrets.ROSE_N8N_SENDING_TOKEN || '' }}
      ROSE_N8N_RECEIVING_TOKEN: ${{ secrets.ROSE_N8N_RECEIVING_TOKEN || '' }}
      ROSE_N8N_ALLOWED_HOST: ${{ vars.N8N_ALLOWED_HOST || '' }}
      ROSE_QUIET: "1"
      ROSE_LANGS_RAW: ${{ vars.ROSE_LANGUAGES }}
      ROSE_TRANSLATION_BRANCH: rose/translations
      ROSE_QUEUE_LABEL: rose
      ROSE_SENT_LABEL: rose-sent
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install translation workflow dependencies
        run: |
          python -m pip install --upgrade pip
          pip install PyYAML ruamel.yaml Babel

      # Language defaults: if no rose:{lang} labels exist, use all configured languages.
      - name: Select merged PRs since last success
        id: queue_entries
        uses: actions/github-script@v7
        env:
          ROSE_LANGS_RAW: ${{ env.ROSE_LANGS_RAW }}
          ROSE_QUEUE_LABEL: ${{ env.ROSE_QUEUE_LABEL }}
          ROSE_SENT_LABEL: ${{ env.ROSE_SENT_LABEL }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const varName = 'ROSE_LANGUAGES';
            const rawLangs = process.env.ROSE_LANGS_RAW || '';
            const queueLabel = (process.env.ROSE_QUEUE_LABEL || 'rose').toLowerCase();
            const sentLabel = (process.env.ROSE_SENT_LABEL || 'rose-sent').toLowerCase();
            const workflowFile = 'rose-orchestration.yml';

            const parseLanguages = (value) => {
              const trimmed = String(value || '').trim();
              if (!trimmed) {
                throw new Error(
                  `Repository variable "${varName}" is required but not set (e.g., "pt es fr" or ["pt","es","fr"]).`
                );
              }
              if (trimmed.startsWith('[')) {
                const parsed = JSON.parse(trimmed);
                if (!Array.isArray(parsed)) {
                  throw new Error(`Repository variable "${varName}" must be a JSON array string.`);
                }
                return parsed.map((item) => String(item).trim()).filter(Boolean);
              }
              return trimmed.split(/[,\s]+/).map((item) => item.trim()).filter(Boolean);
            };

            const languages = parseLanguages(rawLangs);
            const langsLower = languages.map((lang) => lang.toLowerCase());
            const langSet = new Set(langsLower);

            const defaultBranch = process.env.DEFAULT_BRANCH || 'main';
            const searchQuery = [
              `repo:${context.repo.owner}/${context.repo.repo}`,
              'is:pr',
              'is:merged',
              `base:${defaultBranch}`,
              `label:${queueLabel}`,
              `-label:${sentLabel}`,
            ].join(' ');

            const searchResults = await github.paginate(
              github.rest.search.issuesAndPullRequests,
              { q: searchQuery, per_page: 100 }
            );

            const entries = [];
            const seen = new Set();

            for (const item of searchResults) {
              if (!item?.number || seen.has(item.number)) {
                continue;
              }
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: item.number,
              });
              if (!pr.merged_at) {
                continue;
              }
              const labels = (pr.labels || []).map((label) => String(label.name).toLowerCase());
              if (labels.includes(sentLabel)) {
                continue;
              }
              if (!labels.includes(queueLabel)) {
                continue;
              }

              const optInSet = new Set(
                labels
                  .filter((label) => label.startsWith(`${queueLabel}:`))
                  .map((label) => label.split(':')[1])
                  .filter((lang) => langSet.has(lang))
              );
              let targetLangs = [];
              if (optInSet.size > 0) {
                targetLangs = langsLower.filter((lang) => optInSet.has(lang));
              } else {
                targetLangs = [...langsLower];
              }

              if (!targetLangs.length) {
                continue;
              }

              const mergeSha = pr.merge_commit_sha;
              if (!mergeSha) {
                core.warning(`PR #${pr.number} missing merge commit SHA; skipping.`);
                continue;
              }
              const baseSha = pr.base?.sha || '';

              entries.push({
                pr_number: pr.number,
                pr_title: pr.title || '',
                pr_url: pr.html_url || '',
                base_sha: baseSha,
                merge_sha: mergeSha,
                languages: targetLangs,
              });
              seen.add(pr.number);
            }

            if (!entries.length) {
              core.info('No merged PRs found with rose labels.');
              core.setOutput('count', '0');
              return;
            }

            const outPath = path.join(process.env.RUNNER_TEMP || '.', 'rose_queue_entries.json');
            fs.writeFileSync(outPath, JSON.stringify(entries, null, 2));
            core.setOutput('queue_file', outPath);
            core.setOutput('count', String(entries.length));

      - name: Run Rose pipeline from queue
        if: ${{ steps.queue_entries.outputs.count != '0' }}
        id: process_queue
        shell: bash
        env:
          QUEUE_FILE: ${{ steps.queue_entries.outputs.queue_file }}
        run: |
          set -euo pipefail

          if [[ -z "${N8N_WEBHOOK_URL:-}" ]]; then
            echo "N8N_WEBHOOK_URL_TR secret is required" >&2
            exit 1
          fi

          SUCCESS_FILE="${RUNNER_TEMP}/rose_queue_success.json"
          FAILED_FILE="${RUNNER_TEMP}/rose_queue_failed.json"
          export SUCCESS_FILE FAILED_FILE

          python - <<'PY'
          import json
          import os
          import subprocess
          import traceback

          queue_file = os.environ.get("QUEUE_FILE")
          success_file = os.environ.get("SUCCESS_FILE")
          failed_file = os.environ.get("FAILED_FILE")
          output_path = os.environ.get("GITHUB_OUTPUT")

          if not queue_file or not os.path.exists(queue_file):
              raise SystemExit("Queue file missing; aborting.")

          with open(queue_file, "r", encoding="utf-8") as handle:
              entries = json.load(handle)

          if not entries:
              print("No queued entries to process.")
              entries = []

          successes = []
          failures = []

          def ensure_commit(sha: str) -> None:
              if not sha:
                  return
              try:
                  subprocess.run(["git", "cat-file", "-e", sha], check=True, stdout=subprocess.DEVNULL)
              except subprocess.CalledProcessError:
                  subprocess.run(["git", "fetch", "--depth=1", "origin", sha], check=True)

          for entry in entries:
              pr_number = entry.get("pr_number")
              base_sha = entry.get("base_sha")
              merge_sha = entry.get("merge_sha")
              languages = entry.get("languages") or []
              if not merge_sha or not languages:
                  reason = "missing merge SHA or languages"
                  failures.append({**entry, "error": reason})
                  print(f"Skipping entry for PR {pr_number}: {reason}.")
                  continue
              if not base_sha or base_sha == "unknown":
                  base_sha = subprocess.check_output(
                      ["git", "rev-parse", f"{merge_sha}^1"], text=True
                  ).strip()
              ensure_commit(base_sha)
              ensure_commit(merge_sha)

              diff_files = subprocess.check_output(
                  ["git", "diff", "--name-only", base_sha, merge_sha], text=True
              ).splitlines()

              langs_lower = [lang.lower() for lang in languages]

              def should_include(path: str) -> bool:
                  path_lower = path.lower()
                  if path_lower.endswith(".md"):
                      return True
                  if path_lower == ".nav.yml" or path_lower.endswith("/.nav.yml"):
                      return True
                  if path_lower.startswith(".snippets/text/") and path_lower.endswith(".json"):
                      return True
                  return False

              def is_excluded(path: str) -> bool:
                  path_lower = path.lower()
                  excluded_prefixes = [".github/", "node_modules/", "dist/", "site/"]
                  if any(path_lower.startswith(prefix) for prefix in excluded_prefixes):
                      return True
                  for lang in langs_lower:
                      if path_lower.startswith(f"{lang}/"):
                          return True
                      if path_lower.startswith(f"text/{lang}/"):
                          return True
                      if path_lower.startswith(f".snippets/text/{lang}/"):
                          return True
                      if path_lower.startswith(f".snippets/{lang}/"):
                          return True
                  return False

              include_files = [
                  path for path in diff_files if should_include(path) and not is_excluded(path)
              ]

              if not include_files:
                  reason = "no eligible files to translate"
                  failures.append({**entry, "error": reason})
                  print(f"Skipping PR #{pr_number}: {reason}.")
                  continue

              env = os.environ.copy()
              env["ROSE_PRESERVE_TRANSLATIONS"] = "1"
              env["ROSE_INCLUDE_FILES"] = "\n".join(include_files)

              cmd = [
                  "python",
                  "scripts/translation-workflow/rose_pipeline.py",
                  "--base",
                  base_sha,
                  "--head",
                  merge_sha,
                  "--n8n-webhook",
                  env["N8N_WEBHOOK_URL"],
                  "--languages",
              ] + languages

              print(f"Processing PR #{pr_number} ({', '.join(languages)})")
              try:
                  subprocess.run(cmd, check=True, env=env)
                  successes.append(entry)
              except subprocess.CalledProcessError as exc:
                  reason = f"pipeline failed (exit {exc.returncode})"
                  failures.append({**entry, "error": reason})
                  print(f"PR #{pr_number} failed: {reason}")
              except Exception as exc:
                  reason = f"unexpected error: {exc}"
                  failures.append({**entry, "error": reason})
                  print(f"PR #{pr_number} failed: {reason}")
                  traceback.print_exc()

          if success_file:
              with open(success_file, "w", encoding="utf-8") as handle:
                  json.dump(successes, handle, indent=2)
          if failed_file:
              with open(failed_file, "w", encoding="utf-8") as handle:
                  json.dump(failures, handle, indent=2)

          if output_path:
              with open(output_path, "a", encoding="utf-8") as handle:
                  handle.write(f"success_file={success_file}\n")
                  handle.write(f"failed_file={failed_file}\n")
                  handle.write(f"success_count={len(successes)}\n")
                  handle.write(f"failed_count={len(failures)}\n")
          PY

      - name: Append sent PRs to job summary
        if: ${{ steps.process_queue.outputs.success_count != '0' }}
        uses: actions/github-script@v7
        env:
          SUCCESS_FILE: ${{ steps.process_queue.outputs.success_file }}
        with:
          script: |
            const fs = require('fs');

            const successFile = process.env.SUCCESS_FILE;
            if (!successFile || !fs.existsSync(successFile)) {
              core.info('Success file missing; skipping PR summary.');
              return;
            }

            const entries = JSON.parse(fs.readFileSync(successFile, 'utf8'));
            if (!entries.length) {
              core.info('No sent PRs to summarize.');
              return;
            }

            const lines = [];
            lines.push('<details>');
            lines.push(`<summary>Sent PRs (${entries.length})</summary>`);
            lines.push('');
            for (const entry of entries) {
              const prNumber = entry.pr_number;
              const prTitle = entry.pr_title || '';
              const prUrl = entry.pr_url || '';
              if (prNumber && prUrl) {
                lines.push(`- [#${prNumber}](${prUrl}) — ${prTitle}`);
              } else if (prNumber) {
                lines.push(`- #${prNumber} — ${prTitle}`);
              } else {
                lines.push(`- ${prTitle || 'PR entry'}`);
              }
            }
            lines.push('');
            lines.push('</details>');
            lines.push('');

            await fs.promises.appendFile(process.env.GITHUB_STEP_SUMMARY, lines.join('\n'));

      - name: Capture success payload
        if: ${{ steps.process_queue.outputs.success_count != '0' }}
        id: success_payload
        shell: bash
        env:
          SUCCESS_FILE: ${{ steps.process_queue.outputs.success_file }}
        run: |
          if [[ -f "$SUCCESS_FILE" ]]; then
            payload="$(base64 -w 0 "$SUCCESS_FILE")"
            echo "payload=$payload" >> "$GITHUB_OUTPUT"
          else
            echo "payload=" >> "$GITHUB_OUTPUT"
          fi

      - name: Prepare temporary summary directory
        if: ${{ steps.process_queue.outputs.success_count != '0' }}
        id: temp_summary
        run: |
          TMP_DIR=$(mktemp -d)
          echo "dir=$TMP_DIR" >> "$GITHUB_OUTPUT"

      - name: Generate summary markdown
        if: ${{ steps.process_queue.outputs.success_count != '0' }}
        shell: bash
        run: |
          SUMMARY_JSON="scripts/translations/summary_report.json"
          SUMMARY_MD="${{ steps.temp_summary.outputs.dir }}/summary.md"
          if [[ ! -f "$SUMMARY_JSON" ]]; then
            echo '{}' > "$SUMMARY_JSON"
          fi
          python scripts/translation-workflow/render_summary.py \
            --summary "$SUMMARY_JSON" \
            --output "$SUMMARY_MD"

      - name: Append translation summary to job summary
        if: ${{ steps.process_queue.outputs.success_count != '0' }}
        shell: bash
        run: |
          SUMMARY_MD="${{ steps.temp_summary.outputs.dir }}/summary.md"
          if [[ -f "$SUMMARY_MD" ]]; then
            cat "$SUMMARY_MD" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "Summary markdown not found; skipping job summary update."
          fi

      - name: Cleanup translation artifacts
        if: ${{ steps.process_queue.outputs.success_count != '0' }}
        run: rm -rf scripts/translations

      - name: Push translation branch
        if: ${{ steps.process_queue.outputs.success_count != '0' }}
        id: push_branch
        shell: bash
        env:
          TRANSLATION_BRANCH: ${{ env.ROSE_TRANSLATION_BRANCH }}
        run: |
          set -euo pipefail
          restore_commit="$(git rev-parse HEAD)"
          restore_branch="$(git symbolic-ref --quiet --short HEAD || true)"
          changes="$(git status --porcelain)"
          echo "branch=${TRANSLATION_BRANCH}" >> "$GITHUB_OUTPUT"
          if [[ -z "$changes" ]]; then
            echo "No translation changes detected; skipping branch push."
            echo "pushed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git fetch --prune origin
          git fetch origin "$TRANSLATION_BRANCH":"refs/remotes/origin/$TRANSLATION_BRANCH" || true
          git branch -D "$TRANSLATION_BRANCH" 2>/dev/null || true
          git checkout -B "$TRANSLATION_BRANCH"
          git add -A
          if git diff --cached --quiet; then
            echo "No staged changes to commit; skipping branch push."
            if [[ -n "$restore_branch" ]]; then
              git checkout "$restore_branch"
            else
              git checkout --detach "$restore_commit"
            fi
            echo "pushed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          git commit -m "chore(rose): sync translations from queue"
          if git show-ref --verify --quiet "refs/remotes/origin/$TRANSLATION_BRANCH"; then
            git merge --no-edit -X ours "refs/remotes/origin/$TRANSLATION_BRANCH"
          else
            echo "No existing remote branch $TRANSLATION_BRANCH; starting fresh."
          fi
          git push --force-with-lease origin "$TRANSLATION_BRANCH"
          if [[ -n "$restore_branch" ]]; then
            git checkout "$restore_branch"
          else
            git checkout --detach "$restore_commit"
          fi
          echo "pushed=true" >> "$GITHUB_OUTPUT"

  mark-sent:
    name: Mark PRs as Sent
    if: ${{ needs.process-queue.result == 'success' && needs.process-queue.outputs.success_count != '0' }}
    needs: process-queue
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    env:
      ROSE_QUEUE_LABEL: rose
      ROSE_SENT_LABEL: rose-sent
    steps:
      - name: Mark PRs as sent
        uses: actions/github-script@v7
        env:
          SUCCESS_PAYLOAD: ${{ needs.process-queue.outputs.success_payload }}
        with:
          script: |
            const payload = process.env.SUCCESS_PAYLOAD || '';
            const queueLabel = (process.env.ROSE_QUEUE_LABEL || 'rose').toLowerCase();
            const sentLabel = (process.env.ROSE_SENT_LABEL || 'rose-sent').toLowerCase();

            if (!payload) {
              core.info('No successful entries found; skipping label updates.');
              return;
            }

            let successEntries = [];
            try {
              const decoded = Buffer.from(payload, 'base64').toString('utf8');
              successEntries = JSON.parse(decoded);
            } catch (error) {
              core.warning(`Failed to decode success payload: ${error.message}`);
              return;
            }

            if (!successEntries.length) {
              core.info('No successful entries found; skipping label updates.');
              return;
            }

            for (const entry of successEntries) {
              const prNumber = entry.pr_number;
              if (!prNumber) {
                continue;
              }
              let sentApplied = false;
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: [sentLabel],
                });
                sentApplied = true;
              } catch (error) {
                core.warning(`Failed to add ${sentLabel} to PR #${prNumber}: ${error.message}`);
              }
              if (!sentApplied) {
                continue;
              }
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: queueLabel,
                });
              } catch (error) {
                core.warning(`Failed to remove ${queueLabel} from PR #${prNumber}: ${error.message}`);
              }
            }

  sync-rose-branch:
    name: Sync rose/translations with default branch
    if: ${{ github.event_name == 'push' && github.ref == format('refs/heads/{0}', github.event.repository.default_branch) }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Merge default branch into rose/translations
        shell: bash
        env:
          SOURCE_BRANCH: ${{ github.event.repository.default_branch }}
          TARGET_BRANCH: rose/translations
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git fetch origin "$SOURCE_BRANCH"
          if git show-ref --verify --quiet "refs/remotes/origin/$TARGET_BRANCH"; then
            git fetch origin "$TARGET_BRANCH"
            git checkout -B "$TARGET_BRANCH" "refs/remotes/origin/$TARGET_BRANCH"
          else
            git checkout -B "$TARGET_BRANCH" "refs/remotes/origin/$SOURCE_BRANCH"
          fi

          # Prefer main/master when conflicts occur to keep translations branch aligned with source.
          git merge --no-edit -X theirs "refs/remotes/origin/$SOURCE_BRANCH"

          local_head="$(git rev-parse HEAD)"
          remote_head="$(git rev-parse "refs/remotes/origin/$TARGET_BRANCH" 2>/dev/null || true)"
          if [[ -n "$remote_head" && "$local_head" == "$remote_head" ]]; then
            echo "rose/translations already up to date with $SOURCE_BRANCH."
            exit 0
          fi
          git push origin "$TARGET_BRANCH"

  guard:
    name: Permission Guard
    if: ${{ github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    outputs:
      allowed: ${{ steps.permission_check.outputs.allowed }}
      merged_by_allowed: ${{ steps.merged_actor_check.outputs.allowed || steps.permission_check.outputs.allowed }}
    steps:
      - name: Verify permissions
        id: permission_check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const actor = context.actor;
            const { data } = await github.rest.repos.getCollaboratorPermissionLevel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              username: actor,
            });
            const permission = (data && data.permission) ? data.permission : 'none';
            core.info(`Actor ${actor} has permission level: ${permission}`);
            const allowedPermissions = new Set(['admin', 'maintain', 'write']);
            const allowed = allowedPermissions.has(permission) ? 'true' : 'false';
            core.setOutput('allowed', allowed);
      - name: Halt unauthorized dispatch
        if: ${{ steps.permission_check.outputs.allowed != 'true' }}
        run: |
          echo "::warning::${{ github.actor }} is not an admin/maintainer/write on this repository; skipping pipeline."
      - name: Verify merged-by permissions
        if: ${{ github.event_name == 'pull_request' && github.event.pull_request.merged == true }}
        id: merged_actor_check
        uses: actions/github-script@v7
        env:
          DISPATCH_ALLOWED: ${{ steps.permission_check.outputs.allowed }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const mergedBy = context.payload.pull_request.merged_by?.login;
            const fallback = process.env.DISPATCH_ALLOWED === 'true' ? 'true' : 'false';
            if (!mergedBy) {
              core.setOutput('allowed', fallback);
              core.info('Pull request merge has no merged_by; falling back to dispatcher permissions.');
              return;
            }
            const { data } = await github.rest.repos.getCollaboratorPermissionLevel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              username: mergedBy,
            });
            const permission = (data && data.permission) ? data.permission : 'none';
            const allowedPermissions = new Set(['admin', 'maintain', 'write']);
            const allowed = allowedPermissions.has(permission) ? 'true' : 'false';
            core.info(`Merged-by actor ${mergedBy} has permission level: ${permission}`);
            core.setOutput('allowed', allowed);

  run-pipeline:
    name: Rose's Translation Pipeline
    environment: translations
    needs: guard
    if: ${{ github.event_name == 'workflow_dispatch' && needs.guard.outputs.allowed == 'true' && inputs.file_filter != 'run_queue' && inputs.file_filter != 'first_run' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      N8N_WEBHOOK_URL: ${{ secrets.N8N_WEBHOOK_URL_TR }}
      ROSE_N8N_SENDING_TOKEN: ${{ secrets.N8N_SENDING_TOKEN || '' }}
      ROSE_N8N_RECEIVING_TOKEN: ${{ secrets.N8N_RECEIVING_TOKEN || '' }}
      ROSE_N8N_ALLOWED_HOST: ${{ vars.N8N_ALLOWED_HOST || '' }}
      ROSE_QUIET: "1"
      ROSE_INCLUDE_FILES: ${{ github.event_name == 'workflow_dispatch' && inputs.file_filter || '' }}
      ROSE_INCLUDE_FULL: ${{ github.event_name == 'workflow_dispatch' && inputs.include_full || '' }}
      ROSE_LANGUAGES: ${{ vars.ROSE_LANGUAGES }}
      ROSE_TRANSLATION_BRANCH: rose/translations
    steps:
      - name: Determine translation parameters
        id: refs
        shell: bash
        run: |
          DEFAULT_LANGS="${ROSE_LANGUAGES:-es fr pt}"
          normalize_ref() {
            local ref="$1"
            if [[ -z "$ref" ]]; then
              echo ""
            elif [[ "$ref" == "HEAD" ]]; then
              echo "$ref"
            elif [[ "$ref" =~ ^[0-9a-f]{7,40}$ ]]; then
              echo "$ref"
            elif [[ "$ref" == refs/heads/* ]]; then
              echo "origin/${ref#refs/heads/}"
            elif [[ "$ref" == origin/* ]]; then
              echo "$ref"
            elif [[ "$ref" == refs/* ]]; then
              echo "$ref"
            else
              echo "origin/$ref"
            fi
          }
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            raw_base="${{ inputs.base_ref }}"
            raw_head="${{ inputs.head_ref }}"
            if [[ -z "${{ inputs.languages }}" ]]; then
              echo "languages input is required for manual dispatch (e.g., \"es fr pt\")" >&2
              exit 1
            fi
            diff_base="$(normalize_ref "$raw_base")"
            diff_head="$(normalize_ref "$raw_head")"
            pr_base="$raw_head"
            langs="${{ inputs.languages }}"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            raw_base="${{ github.event.pull_request.base.ref }}"
            raw_head="${{ github.event.pull_request.head.ref }}"
            diff_base="${{ github.event.pull_request.base.sha }}"
            diff_head="${{ github.event.pull_request.head.sha }}"
            pr_base="${{ github.event.pull_request.base.ref }}"
            langs="$DEFAULT_LANGS"
          else
            branch="${GITHUB_REF_NAME:-${GITHUB_REF##*/}}"
            diff_base="${{ github.event.before }}"
            if [[ -z "$diff_base" || "$diff_base" == "0000000000000000000000000000000000000000" ]]; then
              diff_base="origin/${branch}"
            fi
            diff_head="HEAD"
            pr_base="${branch}"
            langs="$DEFAULT_LANGS"
          fi
          echo "diff_base=$diff_base" >> "$GITHUB_OUTPUT"
          echo "diff_head=$diff_head" >> "$GITHUB_OUTPUT"
          echo "pr_base=$pr_base" >> "$GITHUB_OUTPUT"
          echo "languages=$langs" >> "$GITHUB_OUTPUT"

      # 1) Fetch the repo so the pipeline can diff and modify files.
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch manual dispatch refs
        if: ${{ github.event_name == 'workflow_dispatch' }}
        shell: bash
        env:
          RAW_BASE: ${{ inputs.base_ref }}
          RAW_HEAD: ${{ inputs.head_ref }}
          DIFF_BASE: ${{ steps.refs.outputs.diff_base }}
          DIFF_HEAD: ${{ steps.refs.outputs.diff_head }}
        run: |
          set -euo pipefail
          fetch_ref() {
            local raw="$1"
            local normalized="$2"
            if [[ -z "$raw" || "$raw" == "HEAD" || "$raw" =~ ^[0-9a-f]{7,40}$ ]]; then
              return
            fi
            if [[ "$normalized" == origin/* ]]; then
              git fetch origin "${normalized#origin/}"
            else
              git fetch origin "$normalized:$normalized"
            fi
          }
          fetch_ref "$RAW_BASE" "$DIFF_BASE"
          fetch_ref "$RAW_HEAD" "$DIFF_HEAD"

      # 2) Install a consistent Python interpreter for all helper scripts.
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install translation workflow dependencies
        run: |
          python -m pip install --upgrade pip
          pip install PyYAML ruamel.yaml Babel

      # 3) Kick off Rose's orchestrator (diff -> n8n -> verify -> build).
      - name: Run Rose pipeline
        shell: bash
        run: |
          set -euo pipefail

          # Abort early if the webhook secret is missing.
          if [[ -z "${N8N_WEBHOOK_URL:-}" ]]; then
            echo "N8N_WEBHOOK_URL_TR secret is required" >&2
            exit 1
          fi

          LANGS="${{ steps.refs.outputs.languages }}"
          export ROSE_PRESERVE_TRANSLATIONS=1

          CMD=(python scripts/translation-workflow/rose_pipeline.py \
            --base "${{ steps.refs.outputs.diff_base }}" \
            --head "${{ steps.refs.outputs.diff_head }}" \
            --n8n-webhook "$N8N_WEBHOOK_URL")

          # Pass down the language list one by one.
          CMD+=(--languages)
          for lang in $LANGS; do
            CMD+=("$lang")
          done

          echo "Running: ${CMD[*]}"
          "${CMD[@]}"

      - name: Prepare temporary summary directory
        if: ${{ always() }}
        id: temp_summary
        run: |
          TMP_DIR=$(mktemp -d)
          echo "dir=$TMP_DIR" >> "$GITHUB_OUTPUT"

      - name: Generate summary markdown
        if: ${{ always() }}
        shell: bash
        run: |
          SUMMARY_JSON="scripts/translations/summary_report.json"
          SUMMARY_MD="${{ steps.temp_summary.outputs.dir }}/summary.md"
          if [[ ! -f "$SUMMARY_JSON" ]]; then
            echo '{}' > "$SUMMARY_JSON"
          fi
          python scripts/translation-workflow/render_summary.py \
            --summary "$SUMMARY_JSON" \
            --output "$SUMMARY_MD"

      - name: Append translation summary to job summary
        if: ${{ always() }}
        shell: bash
        run: |
          SUMMARY_MD="${{ steps.temp_summary.outputs.dir }}/summary.md"
          if [[ -f "$SUMMARY_MD" ]]; then
            cat "$SUMMARY_MD" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "Summary markdown not found; skipping job summary update."
          fi

      - name: Cleanup translation artifacts
        if: ${{ always() }}
        run: rm -rf scripts/translations

      - name: Push translation branch
        id: push_branch
        shell: bash
        env:
          TRANSLATION_BRANCH: ${{ env.ROSE_TRANSLATION_BRANCH }}
          COMMIT_MESSAGE: "chore(rose): sync translations for ${{ steps.refs.outputs.languages }}"
        run: |
          set -euo pipefail
          restore_commit="$(git rev-parse HEAD)"
          restore_branch="$(git symbolic-ref --quiet --short HEAD || true)"
          changes="$(git status --porcelain)"
          echo "branch=${TRANSLATION_BRANCH}" >> "$GITHUB_OUTPUT"
          if [[ -z "$changes" ]]; then
            echo "No translation changes detected; skipping branch push."
            echo "pushed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git fetch --prune origin
          git fetch origin "$TRANSLATION_BRANCH":"refs/remotes/origin/$TRANSLATION_BRANCH" || true
          git branch -D "$TRANSLATION_BRANCH" 2>/dev/null || true
          git checkout -B "$TRANSLATION_BRANCH"
          git add -A
          if git diff --cached --quiet; then
            echo "No staged changes to commit; skipping branch push."
            if [[ -n "$restore_branch" ]]; then
              git checkout "$restore_branch"
            else
              git checkout --detach "$restore_commit"
            fi
            echo "pushed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          git commit -m "$COMMIT_MESSAGE"
          if git show-ref --verify --quiet "refs/remotes/origin/$TRANSLATION_BRANCH"; then
            git merge --no-edit -X ours "refs/remotes/origin/$TRANSLATION_BRANCH"
          else
            echo "No existing remote branch $TRANSLATION_BRANCH; starting fresh."
          fi
          git push --force-with-lease origin "$TRANSLATION_BRANCH"
          if [[ -n "$restore_branch" ]]; then
            git checkout "$restore_branch"
          else
            git checkout --detach "$restore_commit"
          fi
          echo "pushed=true" >> "$GITHUB_OUTPUT"

      - name: Post translation branch instructions
        if: ${{ always() }}
        shell: bash
        env:
          TRANSLATION_BRANCH: ${{ steps.push_branch.outputs.branch }}
          PUSHED: ${{ steps.push_branch.outputs.pushed }}
          BASE_BRANCH: ${{ steps.refs.outputs.pr_base }}
        run: |
          if [[ -z "${TRANSLATION_BRANCH}" ]]; then
            exit 0
          fi
          {
            echo "### Translation branch"
            echo ""
            if [[ "${PUSHED}" == "true" ]]; then
              echo "- Branch with translations: \`${TRANSLATION_BRANCH}\`"
              echo "- Base branch: \`${BASE_BRANCH}\`"
              echo "- Summary file: \`scripts/translations/summary_report.json\`"
              echo ""
              echo "Open a pull request manually from the rose/translations branch above"
            else
              echo "- No translation changes were committed during this run."
            fi
          } >> "$GITHUB_STEP_SUMMARY"

  first-run:
    name: Rose First Run (Batched)
    environment: translations
    needs: guard
    if: ${{ github.event_name == 'workflow_dispatch' && needs.guard.outputs.allowed == 'true' && inputs.file_filter == 'first_run' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      N8N_WEBHOOK_URL: ${{ secrets.N8N_WEBHOOK_URL_TR }}
      ROSE_N8N_SENDING_TOKEN: ${{ secrets.N8N_SENDING_TOKEN || '' }}
      ROSE_N8N_RECEIVING_TOKEN: ${{ secrets.N8N_RECEIVING_TOKEN || '' }}
      ROSE_N8N_ALLOWED_HOST: ${{ vars.N8N_ALLOWED_HOST || '' }}
      ROSE_QUIET: "1"
      ROSE_INCLUDE_FULL: "true"
      ROSE_FIRST_RUN_LOCALE: "1"
      ROSE_LANGUAGES: ${{ vars.ROSE_LANGUAGES }}
      ROSE_TRANSLATION_BRANCH: rose/translations
    steps:
      - name: Determine translation parameters
        id: refs
        shell: bash
        run: |
          normalize_ref() {
            local ref="$1"
            if [[ -z "$ref" ]]; then
              echo ""
            elif [[ "$ref" == "HEAD" ]]; then
              echo "$ref"
            elif [[ "$ref" =~ ^[0-9a-f]{7,40}$ ]]; then
              echo "$ref"
            elif [[ "$ref" == refs/heads/* ]]; then
              echo "origin/${ref#refs/heads/}"
            elif [[ "$ref" == origin/* ]]; then
              echo "$ref"
            elif [[ "$ref" == refs/* ]]; then
              echo "$ref"
            else
              echo "origin/$ref"
            fi
          }
          raw_base="${{ inputs.base_ref }}"
          raw_head="${{ inputs.head_ref }}"
          if [[ -z "${{ inputs.languages }}" ]]; then
            echo "languages input is required for manual dispatch (e.g., \"es fr pt\")" >&2
            exit 1
          fi
          diff_base="$(normalize_ref "$raw_base")"
          diff_head="$(normalize_ref "$raw_head")"
          pr_base="$raw_head"
          langs="${{ inputs.languages }}"
          echo "diff_base=$diff_base" >> "$GITHUB_OUTPUT"
          echo "diff_head=$diff_head" >> "$GITHUB_OUTPUT"
          echo "pr_base=$pr_base" >> "$GITHUB_OUTPUT"
          echo "languages=$langs" >> "$GITHUB_OUTPUT"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch manual dispatch refs
        shell: bash
        env:
          RAW_BASE: ${{ inputs.base_ref }}
          RAW_HEAD: ${{ inputs.head_ref }}
          DIFF_BASE: ${{ steps.refs.outputs.diff_base }}
          DIFF_HEAD: ${{ steps.refs.outputs.diff_head }}
        run: |
          set -euo pipefail
          fetch_ref() {
            local raw="$1"
            local normalized="$2"
            if [[ -z "$raw" || "$raw" == "HEAD" || "$raw" =~ ^[0-9a-f]{7,40}$ ]]; then
              return
            fi
            if [[ "$normalized" == origin/* ]]; then
              git fetch origin "${normalized#origin/}"
            else
              git fetch origin "$normalized:$normalized"
            fi
          }
          fetch_ref "$RAW_BASE" "$DIFF_BASE"
          fetch_ref "$RAW_HEAD" "$DIFF_HEAD"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install translation workflow dependencies
        run: |
          python -m pip install --upgrade pip
          pip install PyYAML ruamel.yaml Babel

      - name: Run Rose pipeline in first_run batches
        shell: bash
        run: |
          set -uo pipefail

          if [[ -z "${N8N_WEBHOOK_URL:-}" ]]; then
            echo "N8N_WEBHOOK_URL_TR secret is required" >&2
            exit 1
          fi

          export ROSE_PRESERVE_TRANSLATIONS=1

          LANGS="${{ steps.refs.outputs.languages }}"
          PLAN_PATH="$(python scripts/translation-workflow/first_run_batches.py --languages "$LANGS")"
          echo "first_run plan: ${PLAN_PATH}"

          FAIL_LOG="scripts/translations/first_run_failures.jsonl"
          : > "$FAIL_LOG"
          failures=0
          batches=0

          run_one() {
            local lang="$1"
            local batch_dirs_json="$2"
            local include_files="$3"

            export ROSE_INCLUDE_FILES="$include_files"
            CMD=(python scripts/translation-workflow/rose_pipeline.py \
              --base "${{ steps.refs.outputs.diff_base }}" \
              --head "${{ steps.refs.outputs.diff_head }}" \
              --n8n-webhook "$N8N_WEBHOOK_URL" \
              --languages "$lang")

            echo "Running batch for lang=${lang}"
            echo "Include paths:"
            printf '%s\n' "$include_files"
            "${CMD[@]}"
          }

          for lang in $LANGS; do
            # Include locale/en.yml for first_run if the target locale file doesn't exist yet.
            if [[ ! -f "locale/${lang}.yml" && ! -f "locale/${lang}.yaml" ]]; then
              batches=$((batches + 1))
              locale_batch_json='["locale/en.yml"]'
              include_files="locale/en.yml"

              if ! run_one "$lang" "$locale_batch_json" "$include_files"; then
                echo "Locale batch failed; retrying once (lang=${lang})..." >&2
                if ! run_one "$lang" "$locale_batch_json" "$include_files"; then
                  failures=$((failures + 1))
                  printf '%s\n' "$(jq -nc --arg lang "$lang" --argjson dirs "$locale_batch_json" '{language:$lang, batch_dirs:$dirs}')" >> "$FAIL_LOG"
                  echo "Locale batch failed twice; logged and continuing (lang=${lang})." >&2
                fi
              fi
            fi

            batch_json_list="$(jq -c --arg lang "$lang" '.batches_by_language[$lang][]? // empty' "$PLAN_PATH")"
            if [[ -z "$batch_json_list" ]]; then
              echo "No missing directories detected for ${lang}; skipping."
              continue
            fi

            while IFS= read -r batch_dirs_json; do
              [[ -z "$batch_dirs_json" ]] && continue
              batches=$((batches + 1))

              include_files="$(python - <<PY\nimport json\narr=json.loads('''$batch_dirs_json''')\nprint('\\n'.join(str(x) for x in arr if str(x).strip()))\nPY\n)"
              if [[ -z "$include_files" ]]; then
                continue
              fi

              if run_one "$lang" "$batch_dirs_json" "$include_files"; then
                continue
              fi

              echo "Batch failed; retrying once (lang=${lang})..." >&2
              if run_one "$lang" "$batch_dirs_json" "$include_files"; then
                echo "Retry succeeded (lang=${lang})."
                continue
              fi

              failures=$((failures + 1))
              printf '%s\n' "$(jq -nc --arg lang "$lang" --argjson dirs "$batch_dirs_json" '{language:$lang, batch_dirs:$dirs}')" >> "$FAIL_LOG"
              echo "Batch failed twice; logged and continuing (lang=${lang})." >&2
            done <<< "$batch_json_list"
          done

          echo "first_run batches processed: $batches"
          echo "first_run batches failed: $failures"
          if [[ "$failures" -gt 0 ]]; then
            echo "Failures logged in $FAIL_LOG"
          fi

      - name: Prepare temporary summary directory
        if: ${{ always() }}
        id: temp_summary
        run: |
          TMP_DIR=$(mktemp -d)
          echo "dir=$TMP_DIR" >> "$GITHUB_OUTPUT"

      - name: Generate summary markdown
        if: ${{ always() }}
        shell: bash
        run: |
          SUMMARY_JSON="scripts/translations/summary_report.json"
          SUMMARY_MD="${{ steps.temp_summary.outputs.dir }}/summary.md"
          if [[ ! -f "$SUMMARY_JSON" ]]; then
            echo '{}' > "$SUMMARY_JSON"
          fi
          python scripts/translation-workflow/render_summary.py \
            --summary "$SUMMARY_JSON" \
            --output "$SUMMARY_MD"

      - name: Append translation summary to job summary
        if: ${{ always() }}
        shell: bash
        run: |
          SUMMARY_MD="${{ steps.temp_summary.outputs.dir }}/summary.md"
          if [[ -f "$SUMMARY_MD" ]]; then
            cat "$SUMMARY_MD" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "Summary markdown not found; skipping job summary update."
          fi
          FAIL_LOG="scripts/translations/first_run_failures.jsonl"
          if [[ -s "$FAIL_LOG" ]]; then
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "### first_run failures" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo '```jsonl' >> "$GITHUB_STEP_SUMMARY"
            cat "$FAIL_LOG" >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Cleanup translation artifacts
        if: ${{ always() }}
        run: rm -rf scripts/translations

      - name: Push translation branch
        id: push_branch
        shell: bash
        env:
          TRANSLATION_BRANCH: ${{ env.ROSE_TRANSLATION_BRANCH }}
          COMMIT_MESSAGE: "chore(rose): first_run sync translations for ${{ steps.refs.outputs.languages }}"
        run: |
          set -euo pipefail
          restore_commit="$(git rev-parse HEAD)"
          restore_branch="$(git symbolic-ref --quiet --short HEAD || true)"
          changes="$(git status --porcelain)"
          echo "branch=${TRANSLATION_BRANCH}" >> "$GITHUB_OUTPUT"
          if [[ -z "$changes" ]]; then
            echo "No translation changes detected; skipping branch push."
            echo "pushed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git fetch --prune origin
          git fetch origin "$TRANSLATION_BRANCH":"refs/remotes/origin/$TRANSLATION_BRANCH" || true
          git branch -D "$TRANSLATION_BRANCH" 2>/dev/null || true
          git checkout -B "$TRANSLATION_BRANCH"
          git add -A
          if git diff --cached --quiet; then
            echo "No staged changes to commit; skipping branch push."
            if [[ -n "$restore_branch" ]]; then
              git checkout "$restore_branch"
            else
              git checkout --detach "$restore_commit"
            fi
            echo "pushed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          git commit -m "$COMMIT_MESSAGE"
          if git show-ref --verify --quiet "refs/remotes/origin/$TRANSLATION_BRANCH"; then
            git merge --no-edit -X ours "refs/remotes/origin/$TRANSLATION_BRANCH"
          else
            echo "No existing remote branch $TRANSLATION_BRANCH; starting fresh."
          fi
          git push --force-with-lease origin "$TRANSLATION_BRANCH"
          if [[ -n "$restore_branch" ]]; then
            git checkout "$restore_branch"
          else
            git checkout --detach "$restore_commit"
          fi
          echo "pushed=true" >> "$GITHUB_OUTPUT"

      - name: Post translation branch instructions
        if: ${{ always() }}
        shell: bash
        env:
          TRANSLATION_BRANCH: ${{ steps.push_branch.outputs.branch }}
          PUSHED: ${{ steps.push_branch.outputs.pushed }}
          BASE_BRANCH: ${{ steps.refs.outputs.pr_base }}
        run: |
          if [[ -z "${TRANSLATION_BRANCH}" ]]; then
            exit 0
          fi
          {
            echo "### Translation branch"
            echo ""
            if [[ "${PUSHED}" == "true" ]]; then
              echo "- Branch with translations: \`${TRANSLATION_BRANCH}\`"
              echo "- Base branch: \`${BASE_BRANCH}\`"
              echo "- Summary file: \`scripts/translations/summary_report.json\`"
              echo ""
              echo "Open a pull request manually from the rose/translations branch above"
            else
              echo "- No translation changes were committed during this run."
            fi
          } >> "$GITHUB_STEP_SUMMARY"

  notify-on-failure:
    name: Notify on Failure
    runs-on: ubuntu-latest
    needs: [run-pipeline, process-queue, first-run]
    if: ${{ always() && (needs.run-pipeline.result == 'failure' || needs.process-queue.result == 'failure' || needs.first-run.result == 'failure') }}
    env:
      ERROR_WEBHOOK_URL: ${{ secrets.ERROR_WEBHOOK_URL }}
      RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
      WORKFLOW_NAME: ${{ github.workflow }}
      RUN_ID: ${{ github.run_id }}
      RUN_ATTEMPT: ${{ github.run_attempt }}
      ACTOR: ${{ github.actor }}
      REPOSITORY: ${{ github.repository }}
      REF: ${{ github.ref }}
      FAILED_JOB: ${{ needs.run-pipeline.result == 'failure' && 'run-pipeline' || needs.process-queue.result == 'failure' && 'process-queue' || needs.first-run.result == 'failure' && 'first-run' || '' }}
      RUN_PIPELINE_STATUS: ${{ needs.run-pipeline.result }}
      PROCESS_QUEUE_STATUS: ${{ needs.process-queue.result }}
      FIRST_RUN_STATUS: ${{ needs.first-run.result }}
    steps:
      - name: Send failure webhook
        run: |
          set -euo pipefail

          if [[ -z ${ERROR_WEBHOOK_URL:-} ]]; then
            echo "ERROR_WEBHOOK_URL not configured; skipping alert dispatch."
            exit 0
          fi

          payload=$(jq -n \
            --arg repo "$REPOSITORY" \
            --arg ref "$REF" \
            --arg run_url "$RUN_URL" \
            --arg workflow "$WORKFLOW_NAME" \
            --arg run_id "$RUN_ID" \
            --arg run_attempt "$RUN_ATTEMPT" \
            --arg actor "$ACTOR" \
            --arg status "failure" \
            --arg failed_job "$FAILED_JOB" \
            --arg run_pipeline_status "$RUN_PIPELINE_STATUS" \
            --arg process_queue_status "$PROCESS_QUEUE_STATUS" \
            '{repository:$repo, ref:$ref, status:$status, failed_job:$failed_job, run_pipeline_status:$run_pipeline_status, process_queue_status:$process_queue_status, run_url:$run_url, workflow:$workflow, run_id:$run_id, run_attempt:$run_attempt, actor:$actor}')

          curl -sS --fail-with-body --proto '=https' --tlsv1.2 \
            --retry 2 --retry-all-errors \
            --no-progress-meter --http1.1 --noproxy '*' \
            -X POST \
            -H "Content-Type: application/json" \
            --data "$payload" \
            "$ERROR_WEBHOOK_URL"
      - name: Verify merged-by permissions
        if: ${{ github.event_name == 'pull_request' && github.event.pull_request.merged == true }}
        id: merged_actor_check
        uses: actions/github-script@v7
        env:
          DISPATCH_ALLOWED: ${{ steps.permission_check.outputs.allowed }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const mergedBy = context.payload.pull_request.merged_by?.login;
            const fallback = process.env.DISPATCH_ALLOWED === 'true' ? 'true' : 'false';
            if (!mergedBy) {
              core.setOutput('allowed', fallback);
              core.info('Pull request merge has no merged_by; falling back to dispatcher permissions.');
              return;
            }
            const { data } = await github.rest.repos.getCollaboratorPermissionLevel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              username: mergedBy,
            });
            const permission = (data && data.permission) ? data.permission : 'none';
            const allowedPermissions = new Set(['admin', 'maintain', 'write']);
            const allowed = allowedPermissions.has(permission) ? 'true' : 'false';
            core.info(`Merged-by actor ${mergedBy} has permission level: ${permission}`);
            core.setOutput('allowed', allowed);
